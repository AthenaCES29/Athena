#include <stdio.h>
#include <string.h>

typedef struct tabelaDePaginas {
	int id[256];
	int primeira;	/*indice da primeira pagina adicionada na tabela de paginas*/
	int ultima;		/*indice da ultima pagina adicionada na tabela de paginas*/
} tabelaDePaginas;

typedef struct TLB {
	int id[16];
	int ultima;		/*indice da ultima pagina adicionada na tabela de paginas*/
} TLB;

/*Recebe um ponteiro para a tabela de paginas, um ponteiro para a tlb, um ponteiro para a memoria,
o conteudo da pagina e um id de uma pagina a ser adiconada e adiciona a pagina
a tabela de paginas e a tlb e seu conteudo a memoria.
A politica de adicao de pagina eh FIFO.*/
void adicionar(tabelaDePaginas* tab, TLB* tlb, char* memoria, char* pagina,  int id) {
	static int quantidade;
	int i;
	/*Adicionar pagina a tabela*/
	if (tab->ultima == 255)
		tab->ultima = 0;
	else
		tab->ultima++;
	tab->id[tab->ultima] = id;
	if (tlb->ultima == 16)
		tlb->ultima = 0;
	else
		tlb->ultima++;
	tlb->id[tlb->ultima] = id;

	/*Adicionar dados a memoria*/
	if (quantidade < 256) {
		quantidade++;
	}
	else {
		if (tab->primeira == 255)
			tab->primeira = 0;
		else
			tab->primeira++;
	}
	for (i = 0; i < 256; i++)
		memoria[tab->primeira*256 + i] = pagina[i];
}

/*Recebe um ponteiro para a TLB e um id de pagina.
Retorna o indice se a pagina com id dado estiver presente ou -1 se nao estiver*/
int buscarNaTabela(tabelaDePaginas* tab, int id) {
	int i;
	for (i = 0; i < 16; i++) {
		if (tab->id[i] == id)
			return i;
	}
	return -1;
}


/*Recebe um ponteiro para a tabela de paginas e um id de pagina.
Retorna o indice se a pagina com id dado estiver presente ou -1 se nao estiver*/
int buscarNaTabela(tabelaDePaginas* tab, int id) {
	int i;
	for (i = 0; i < 256; i++) {
		if (tab->id[i] == id)
			return i;
	}
	return -1;
}


/*Recebe um ponteiro para o arquivo de swap, um ponteiro para um vetor de char (pagina) e
um page id, busca no arquivo swap e escreve no vetor os dados correspondentes aos dados da pagina*/
void buscarNoSWAP(FILE* swap, unsigned char* pagina, int id) {
	int i;
	char high, low;
	fseek(swap, id*256, SEEK_SET);
	fread(pagina, 1, 256, swap);
}

int main(int argc, char *argv[]) {
	tabelaDePaginas tabela;
	TLB tlb;
	char memoria[256*256];
	char pagina[256];

	FILE* entrada;
	FILE* swap;
	FILE* saida;
	char string[10];
	char** endptr;
	int va, pa, des, id;
	int mascara16 = 65535;

	int i;

	tabela.primeira = 0;
	tabela.ultima = 0;
	tlb.ultima = 0;

/*Ler id's do arquivo adresses.txt e abrir arquivo de swap*/
	entrada = fopen(argv[1], "r");
	swap = fopen("BACKING_STORE.bin", "r");
	saida = fopen("saida.txt", "w");

	if (entrada == NULL) {
		printf("Erro, nao foi possivel abrir o arquivo.\n");
		return -1;
	}
	else {
		
		while (fgets(string, 10, entrada) != NULL) {
			va = strtol(string, endptr, 10);
			id = va & mascara16;
			id = id / 256;
			des = va % 256;
			pa = tabela.primeira*256 + des;

			/*Verificar se a tabela esta na tabela de paginas*/
			if (buscarNaTLB(&tlb, id) == -1) {
				if (buscarNaTabela(&tabela, id) == -1) {
					/*Importar para a tabela de paginas e para a memoria*/
					buscarNoSWAP (swap, pagina, id);
					adicionar(&tabela, &tlb, memoria, pagina, id);
				}
			}
			fprintf (saida, "Virtual address: %4d Physical adress: %4d Value: %4d\n", va, pa, memoria[pa]);
		}
	}

	fclose(entrada);
	fclose(swap);
	fclose(saida);

	return 0;
}